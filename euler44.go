/*
 Pentagonal numbers are generated by the formula, Pn=n(3n-1)/2. The first ten
 pentagonal numbers are:

 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

 It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70
 22 = 48, is not pentagonal.

 Find the pair of pentagonal numbers, Pj and Pk, for which their sum and
 difference is pentagonal and D = |Pk Pj| is minimised; what is the value of D?

 Or, find 4 pentagonals. A - B - C = D.

 Generate a few.
 Start with the right. The difference between the last and next-to-last is the threshold.
 Start with the next-to-last and go through backwards, until the number is less than the threshold.
   Is the difference in the array? Use clever searching.
   If it is, run the slice through again.

*/

package main

import (
	"fmt"
	"math"
)

func penta(n int) int {
	return n * ((3 * n) - 1) / 2
}

func is_in(ps []int, t int) (bool, int) {
	// assumes ps is increasing
	// fmt.Println("Searching for", t, "in", ps)
	for i := len(ps) - 1; i >= 0 && ps[i] >= t; i-- {
		if ps[i] == t {
			return true, i
		}
	}
	return false, 0
}

func pentadiff(ps []int) (bool, []int) {
	// start at the right
	// for every number to the left that's higher than the threshold,
	//   find the difference. It'll be to the left.
	// fmt.Println("pentadiff:", ps)
	d := ps[len(ps)-1]
	c := d

	for pointer := len(ps) - 2; ps[pointer] > d/2; pointer-- {
		c = ps[pointer]
		b := d - c
		a := c - b
		left := ps[:pointer]
		if found, _ := is_in(left, b); found == true {
			// fmt.Println(b, c, d, "work. Trying", a, "in", left)
			if ffound, _ := is_in(left, a); ffound == true {
				return true, []int{a, b, c, d}
			}
		}
	}
	return false, []int{}
}

func main() {
	ps := []int{1, 5, 12, 22}
	halt := false
	var nums []int
	for i := 5; halt == false; i++ {
		ps = append(ps, penta(i))
		halt, nums = pentadiff(ps)
		if halt {
			fmt.Println(nums)
		}
	}
}
